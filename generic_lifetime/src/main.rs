fn main() {
    /*
    소유권이라는 개념과 더불어 헷갈리는 개념 중 라이브타임이라는 것이 있다.
    변수의 소유권을 호출하는 함수에게 넘겨주거나 하기 싫을 때 참조자를 사용하는데
    참조자는 라이프타임이라는 것이 존재한다.

    러스트에서 모든 참조자는 라이프타임이라는 것을 가지는데
    라이프타임은 참조자가 유요한 스코프를 의미한다.
    라이프타임이 존재하는 이유는 만약 참조자가 참조한 변수의 수명이 끝나면 그 참조자는 댕글링 참조자가 되버린다.
    참조자에 라이프타임을 적용하면 댕글링 참조자를 원천에 방지할 수 있는 효과가 있다.

    일반적으로는 참조자에 대한 라이프타임은 암묵적으로 추론되며 적을 필요가 없는 경우도 많지만
    라이프타임이 애매 모호한 경우 직접 적어주어야 한다.

    라이프타임으로 인해 댕글링 참조자가 방지되는 것을 보자.
    러스트는 컴파일 타임에 라이프타임도 검사하여 사용자에게 알려준다.
    */
    let str_a = "Hello, world!"; // 프로그램이 종료될때까지 유효한 변수
    let str_ref; // 프로그램이 종료될때까지 유효한 변수
    {
        let str_b = "Hello"; // 이 스코프 내에서만 유효한 변수
        str_ref = &str_a; // str_a를 참조하면 괜찮지만 str_b는 스코프를 나가면 무효화되어 댕글링 포인터가 된다.
        println!("str_ref : [{}]", str_ref); // str_a, str_b 에 대해서 모두 정상 동작
    }
    println!("str_ref : [{}]", str_ref); // str_b를 참조할 시 에러

    /*
    위의 예제는 사용자가 수정하면 되므로 충분히 예견 가능한 문제이다. 하지만 함수가 참조자를 받게되면 발견하기 힘들어진다.
    예를 들어 위의 str_a, str_b의 참조자를 받아 무엇인가 판단을 하여(둘 중 긴 문자열을 찾는다던지) 둘 중 하나를 리턴한다고 하면
    저런 경우에 런타임에 str_a를 리턴하면 문제가 없지만 str_b는 문제가 생기는 것이다.

    이런 경우 "str_a, str_b 두 라이프타임이 동일하다" 라는 것을 컴파일러에게 알려주어서
    인수의 라이프타임 때문에 문제가 생길 것 같으면 컴파일러는 컴파일 오류를 발생시킨다.

    예제를 살펴보자.
    int_max는 정수의 레퍼런스를 받아 둘 중 큰 변수의 레퍼런스를 반환하는 함수이다.
    만얃 함수의 시그니처를 다음과 같이 쓰고 컴파일하면 모두 동일한 라이프타임을 공유하게 하라고 에러가 뜬다.
    변경 전 함수 시그니처      : fn int_max(a: &u32, b: &u32) -> &u32
    컴파일러 권고 함수 시그니처  : fn int_max<'a>(a: &'a u32, b: &'a u32) -> &'a u32

    변경한 함수 시그니처를 보면 제네릭 타입 파라미터처럼 "제네릭 라이프타임 파라미터" 가 들어간다.
    제네릭 라이프타임 파라미터의 값을 보면 'a라고 명시가 되어 있는데
    '은 라이프타임 파라미터를 의미하며 a는 라이프타임 파라미터의 이름을 나타낸다.

    라이프타임 파라미터는 제네릭 파라미터에 뿐만 아니라 변수/인수에도 작성 가능한데
    인수에 제네릭 파라미터를 기재하는 것은 참조자의 라이프타임에 영향을 끼치지 못하며 단순히 관계를 짓기 위해 사용하는 것이다.

    int_max 함수의 제네릭 라이프타임 파라미터에는 a가 들어갔으며 입력 인수 2개, 반환 타입 1개 모두 동일한 라이프타임 a를 가지며
    아래와 같은 코드가 함부로 컴파일되는 것을 막는 역할을 하게 된다.
    */
    /*
    let a: u32 = 10;
    let r: &u32;
    {
        let b: u32 = 20;
        r = int_max(&a, &b);
    }
    println!("r : [{}]", r);
    */

    /*
    변수를 여러개 가지고 있는 구조체에 참조자를 집어 넣으면 라이프타임의 명시가 필요하다.
    왜냐 하면 구조체의 값을 대입한 결과가 하나라도 댕글링 참조자가 되면 안되기 때문이다.
    그래서 참조자를 포함한 구조체는 모두 하나의 라이프타임을 가지도록 통일해야 한다.
    */
}

fn int_max<'a>(a: &'a u32, b: &'a u32) -> &'a u32 {
    if a > b {
        a
    } else {
        b
    }
}

struct NumAndString<'a> {
    num: &'a u32,
    s: &'a str
}