fn main() {
    /*
    러스트에선 함수 정의 키워드가 fn이다.
    러스트에선 함수의 위치를 신경쓰지 않으며 정의만 되어있으면 동작된다.
    */
    subfunc();
    /*
    함수의 인풋을 매개변수나 전달인자라고 부른다.
    매개변수가 있는 함수 정의 시 매개변수에 대한 타입을 정의하여야 한다.
    */
    subfunc_arg(-1234);
    /*
    함수의 본문은 표현식으로 종결되는 구문의 나열로 종결된다.
    러스트는 표현식에 기반한 언어이기 때문에 표현식도 구문의 일부가 된다.
    구문은 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행하며
    표현식은 결과의 값을 산출해 낸다.
    예를 들어 let 키워드를 통해 변수를 만들고 값을 할당하는 것은 구문이며
    표현식은 구문의 부분이 될 수 있다. 혹은 함수를 호출하는 것, 매크로를 호출하는 것도 표현식이다.
    */
    let x = 5; // 여기서 "let x = 5;"는 구문이며 구문의 부분인 리터럴 "5" 는 표현식이다.
    let y = { // 중괄호 전체가 표현식이 된다.
        let x = x + 1; // 중괄호 내 이것은 구문이다.
        x * 2 // 하지만 이것은 표현식이다. 세미콜론을 붙이지 않는 것에 주목하자. 세미콜론을 붙이면 구문으로 바뀐다.
    };
    println!("x : {}, y : {}", x, y);
    /*
    다른 언어들과 마찬가지로 함수는 리턴값이 존재할 수 있다.
    C나 C++과 다르게 리턴되는 값의 타입을 화살표를 이용해서 적어야 한다.
    그리고 리턴되는 값은 함수의 본문의 마지막 표현식을 리턴된다. (return 키워드를 사용해도 되지만 마지막 표현식 이전에 반환할 때 사용한다.)
    */
    println!("is {} odd ? : {}", 12, is_odd(12));
}

fn subfunc() {
    println!("hello my name is subfunc!");
}

fn subfunc_arg(arg: i32) {
    println!("arg : {}", arg);
}

fn is_odd(arg: u64) -> bool { // 이렇게 리턴되는 값이 있을 경우 화살표와 형식을 적어주어야 한다.
    arg % 2 == 1
}