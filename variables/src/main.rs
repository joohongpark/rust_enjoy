fn main() {
    /*
    rust에서의 변수와 가변성
    rust의 기본 변수는 불변성을 가지고 있다. 변수에 불변성을 강제하면 안정성과 동시성을 쉽게 취할 수 있다.
    그래서 별도로 명시하지 않으면 기본 변수에 값을 재할당하는 것이 금지되어 있어 다음과 같은 구문은 금지된다.
    let x = 5;
    x = 6;
    이런 구문을 사용하면 컴파일이 안된다.

    그래서 rust엔 mut라는 접두어를 제공해 변수가 가변성을 가지도록 할 수 있다.
    다음과 같이 수정하면 위 코드는 허용된다.
    let mut x = 5;
    x = 6;
    이렇게 변수를 가변성으로 만드느냐, 불변성으로 만드느냐에 대한 의사 결정을 할 때 버그 예방 외에 여러 요소가 있을 수 있다.
    예를 들면 대규모의 데이터를 다룰때엔 변수를 가변성으로 만드는 것이 새로운 변수 인스턴스를 만드는 것이 비용이 더 적을 수 있다.
    하지만 가독성 및 생산성 면에서는 불변성으로 만드는 것이 더 좋은 선택일 수도 있다.
    */
    // 불변성을 지닌 let 선언
    let val_immut_x = 10;
    println!("val_immut_x : {}", val_immut_x);

    // 가변성을 지닌 let 선언
    let mut val_mut_x = 5;
    println!("val_mut_x (before) : {}", val_mut_x);
    val_mut_x = 6;
    println!("val_mut_x (after) : {}", val_mut_x);


    /*
    궁금할만한 사항이 다른 언어에서 변수에 const를 붙여서 상수로 만드는것과 rust에서의 변수의 불변성이 동일하지 않은가? 라고 생각할 수 있다.
    하지만 rust에서 변수의 불변성과 상수는 좀 다르다.
    1. rust에서 상수는 불변성 그 자체이다. rust에서도 상수를 지정하는 키워드 (const)가 있다.
    2. 상수를 선언할 때에는 값의 유형을 선언해야 한다. 하지만 변수는 그러지 않아도 된다.
    3. 상수는 어느 영역에서도 선언될 수 있다.
    4. 상수는 상수 표현식만 표현 가능하며 함수 호출의 경과값이나 실행 시간에 결정되는 값이 설정될 수 없다.
    5. rust는 상수를 명명할 때 모든 단어를 대문자로 작성해야 한다. (컴파일 에러는 뜨지 않지만 컴파일 경고가 뜬다.)
    상수는 이런 식으로 지정할 수 있다.
    const MAX: u32 = 1024;
    */
    // let과 다른 상수 선언
    const CONST_MAX: u32 = 1024;
    println!("CONST_MAX : {}", CONST_MAX);

    /*
    Shadowing (쉐도잉)
    rust를 헷갈리게 하는 요소 중 하나인 쉐도잉이 있다.
    이전에 선언한 변수와 똑같은 이름의 새 변수를 선언할 수 있다. 새 변수는 이전 변수를 "쉐도우" 한다.
    rust에서는 이 동작을 "쉐도우" 라고 표현한다.
    아래와 같은 동작이 쉐도잉이다.
    let shadow_x = 5; // 바인딩
    let shadow_x = shadow_x + 1; // 쉐도잉
    let shadow_x = shadow_x * 3; // 쉐도잉
    쉐도잉을 할 때에는 값의 유형이 변할수도 있다. 예를 들어 이렇게 해도 된다.
    let spaces = "     ";
    let spaces = spaces.len();
    이런 동작(타입이 변하는 경우)은 쉐도잉은 가능하지만 가변성 변수엔 불가능하다.
    */
    // shadowing
    let mut shadow_x = 5;
    shadow_x = shadow_x + 1;
    shadow_x = shadow_x * 3;
    println!("shadow_x : {}", shadow_x);

    let spaces = "     ";
    println!("spaces : {}", spaces);
    let spaces = spaces.len();
    println!("spaces : {}", spaces);

    /*
    러스트의 값들은 모두 고유의 타입이 있다.
    위에서는 상수를 제외하고 별도로 변수에 타입을 명시하지 않았지만 러스트는 저런 경우는 타입을 알아서 추론해서 대입해준다.
    그런데 모두 그런 경우는 아니고 필요한 경우 타입을 기입해야 한다.
    추가로 러스트는 타입이 정해지면 변경될 수 없다. 변수의 타입은 컴파일 타임에 모두 정해져야 한다.
    */
    let number: u32 = "1234".parse().expect("err");
    println!("1234 -> {}", number);

    /*
    러스트에는 하나의 값으로 표현되는 타입인 스칼라 타입이 있다.(자바의 프리미티브 타입과 비슷할듯) 스칼라 타입엔 4가지 종류가 있다.
    - 정수형
    정수형은 부호가 있으면 i, 부호가 없으면 u로 시작하는 비트 개수로 나타낸다.
    예를 들면 부호있는 8비트는 i8이고 부호없는 64비트는 u64이다.
    비트 개수 대신 size라는 단어를 붙일 수 있다. 예를 들어 64비트 컴퓨터 환경에서 usize는 부호 없는 64비트가 된다.
    정수형 리터럴은 10진수 16진수 2진수는 다른 언어와 비슷하게 표기하며 8진수는 0o 접두사를 붙인다.
    시각적인 구분을 위해 리터럴 내에 언더바를 삽입하는 것이 허용된다.
    예를 들어보자. 언더바는 10진수도 삽입가능하다.
    println!("0xaa -> {}", 0b1010_1010); // 170
    - 부동 소수점
    부동 소수점의 타입은 f32와 f64가 있다. C와 비교하면 float과 double에 대응된다. 기본 부동소수점 타입은 f64이다.
    - boolean
    boolean 타입은 bool로 명시하며 값은 true와 false를 가질 수 있다.
    - 문자
    C나 C++과의 char의 가장 큰 차이점은 char가 1바이트가 아니라는 점이다. 추후에 상세히 다룬다.
    */
    println!("0xaa -> {}", 0b1010_1010); // 170
    let devil_emoji: char = '😈';
    println!("devil_emoji -> {}", devil_emoji);

    /*
    다른 타입의 값들이 묶여있는 복합 타입이라는 것도 있다.
    복합 타입엔 튜플과 배열이 있다.
    튜플은 다양한 타입의 값을 콤마로 구분하여 소괄호로 묶어 선언한다.
    묶여있는 튜플은 패턴 매칭을 사용하여 각각의 다른 이름의 변수로 해체하거나 튜플에 인덱스로 접근할 수 있다.
    배열은 동일 타입으로만 구성되어야 하며 고정된 길이를 가지는 특징이 있다.
    인덱스를 이용해 배열 요소에 접근하며 인덱스로 배열 요소에 접근할 때에는 러스트가 자체적으로 배열 길이와 비교하여 접근 가능한 인덱스인지 확인하며
    접근 불가능한 인덱스인 경우 패닉을 발생시킨다. (C나 C++같은 경우 바로 세그멘테이션 오류 발생함)
    */
    let tup = (2021, '😈');
    println!("year : {}, emoji : {}", tup.0, tup.1);
    let (tup_year, tup_emoji) = tup;
    println!("tup_year : {}, tup_emoji : {}", tup_year, tup_emoji);
    let arr_ten = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let mut index = 2;
    println!("arr_ten[{}] : {}", index, arr_ten[index]);
    index = 20;
    println!("arr_ten[-1] : {}", arr_ten[index]);
}
